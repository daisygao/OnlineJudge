3Sum: easy

3Sum Closest: easy

4Sum: O(n^3) consider efficiency of ArrayList expansion operation

Add Binary: easy

Add Digits: math n - 1

Add Two Numbers: easy

Anagrams: easy

Balanced Binary Tree: easy

Best Time to Buy and Sell Stock: easy

Best Time to Buy and Sell Stock II: easy inflection point 

Best Time to Buy and Sell Stock III: DP

Binary Tree Inorder Traversal: iteratively

Binary Tree Level Order Traversal: easy both queue and buffer methods

Binary Tree Level Order Traversal II: easy

Binary Tree Maximum Path Sum: hard

Binary Tree Postorder Traversal: medium pop condition

Binary Tree Zigzag Level Order Traversal: medium

Candy ※: medium. Greedy algorithm. Similar to Dijsktra

Climbing Stairs: DP

Clone Graph: BFS + hash

Combination Sum: recursion

Combination Sum II: recursion

Combinations: both iterative and recursion

Construct Binary Tree from Inorder and Postorder Traversal: easy

Construct Binary Tree from Preorder and Inorder Traversal: easy

Container With Most Water: hard greedy tricky

Contains Duplicates: cannot sort an empty array; C++ set insert return value is pair

Convert Sorted Array to Binary Search Tree: easy

Convert Sorted List to Binary Search Tree: medium global pointer bottom-up recursion 

Copy List with Random Pointer: deep copy queue

Count and Say: easy

Decode Ways: DP medium

Delete Node in a Linked List: fill instead of "real" deletion

Distinct Subsequences: DP medium

Divide Two Integers: binary medium

Edit Distance: DP medium

Evaluate Reverse Polish Notation: easy

Excel Sheet Column Number: no brainer

First Missing Positive: classic

Flatten Binary Tree to Linked List: easy

Gas Station: easy greedy algorithm. Similar to Longest Consecutive Seq

Generate Parentheses: recursion

Gray Code: classic trick generating subsets or binary numbers

Implement strStr(): easy

Insert Interval: medium

Insertion Sort List: medium

Integer to Roman: medium 

Interleaving String: DP

Invert Binary Tree: recursive

Jump Game: Greedy O(n) BFS or DFS

Jump Game II ※: DP BFS hard

Largest Rectangle in Histogram: left right idx problem. Non-descending sequence using stack

Length of Last Word: easy

Letter Combinations of a Phone Number: easy

Longest Common Prefix: easy

Longest Consecutive Sequence ※: hash

Longest Palindromic Substring: DP 

Longest Substring Without Repeating Characters: O(n) using hash 

Longest Valid Parentheses ※: stack + DP + max O(n) time complexity

Lowest Common Ancestor of a Binary Tree: not neat...

Majority Element: median or Moore voting algorithm

Maximal Rectangle ※: use union-find set to construct the monotone queue instead of the stack. Stack will exceed time limit for large judge. 

Maximum Depth of Binary Tree: easy

Maximum Product Subarray: medium DP

Maximum Subarray: easy

Median of Two Sorted Arrays: binary search hard 

Merge Intervals: easy

Merge k Sorted Lists: priority queue of size k

Merge Sorted Array: easy extremely short code

Merge Two Sorted List: easy

Minimum Depth of Binary Tree: make sure to understand the definition of minDepth which is to count the distance between root and the "leaf" node

Minimum Path Sum: DP

Minimum Window Substring ※: ascii hash 

Move Zeros: think through different cases before coding

Multiply Strings: medium large number or string

N-Queens: easy

N-Queens II: easy

Next Permutation: classic 

Nim Game: math 

Palindrome Number: easy

Palindrome Partitioning: recursion

Palindrome Partitioning II: DP on sol and palindrome

Partition List: easy but kindof tricky..

Pascal's Triangle: DP 

Pascal's Triangle II: DP easy

Path Sum: easy

Path Sum II: easy 

Permutation Sequence: easy 

Permutations: no duplicate recursion medium

Permutations II: next permutation problem

Plus One: easy find the last 9 seq

Populating Next Right Pointers in Each Node: easy

Populating Next Right Pointers in Each Node II: easy from right to left 

Pow(x, n): tricky Integer boundary

Recover Binary Search Tree: both recursively and iteratively medium

Regular Expression Matching: medium recursion

Remove Duplicates from Sorted Array: easy

Remove Duplicates from Sorted Array II: easy

Remove Duplicates from Sorted List: slim code!

Remove Duplicates from Sorted List II: easy

Remove Element: easy

Remove Nth Node From End of List: classic

Reorder List: easy detail..

Restore IP Addresses: recursion easy corner cases..

Reverse Integer: easy overflow

Reverse Linked List II: classic 

Reverse Nodes in k-Group: easy

Reverse Words in a String: easy & tricky

Roman to Integer: easy

Rotate Image: classic details

Rotate List: medium

Same Tree: easy

Scramble String: medium recursion & pruning

Search a 2D Matrix: binary search

Search for a Range: recursion or twice binary search

Search in Rotated Sorted Array: classic 

Search in Rotated Sorted Array II: medium

Search Insert Position: easy

Set Matrix Zeroes: details...

Simplify Path: easy details...

Single Number: easy classic xor

Single Number II ※: bits arithmetics, classic

Sort Colors: Dutch National Flag Problem loop invariant

Spiral Matrix: classic

Spiral Matrix II: easy

Sqrt(x): Newton and binary search 

String to Integer (atoi): boundary

Subsets: easy

Subsets II: both iterative and recursion. Recursion is the same with Combination Sum. Subsets could also use this recursion solution.  

Substring with Concatenation of All Words: hash hash

Sudoku Solver: medium boolean recursion & bit masking & 2-d array to 1-d array

Sum Root to Leaf Numbers: easy top-down

Surrounded Regions: medium queue

Swap Nodes in Pairs: easy fake head

Symmetric Tree: recursively and iteratively by using queues

Text Justification: medium

Trapping Rain Water: double-way DP O(n)

Triangle: DP O(n^2)

Two Sum: hash / quicksort + binary 

Unique Binary Search Trees: DP

Unique Binary Search Trees II: recursion

Unique Paths: DP 1d

Unique Paths II: DP 1d

Valid Anagram: vector initialization

Valid Palindrome: easy

Valid Parentheses: easy

Valid Sudoku: easy

Validate Binary Search Tree : similar to Balanced Tree

Wildcard Matching: hard

Word Break: DP

Word Break II ※: DP + parent + recursion. Note time efficiency

Word Ladder: BFS using queue and HashMap 

Word Ladder II: medium 

Word Pattern: medium

Word Search: recursion easy 

ZigZag Conversion: medium 
