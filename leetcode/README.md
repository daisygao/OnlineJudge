3Sum: easy

3Sum Closest: easy

4Sum: O(n^3) consider efficiency of ArrayList expansion operation

Add Binary: easy

Add Digits: math n - 1

Add Two Numbers: easy

Anagrams: easy

Balanced Binary Tree: easy

Best Time to Buy and Sell Stock: easy

Best Time to Buy and Sell Stock II: easy inflection point 

Best Time to Buy and Sell Stock III: DP

Binary Tree Inorder Traversal: iteratively

Binary Tree Level Order Traversal: one queue solution. queue size = row size 

Binary Tree Level Order Traversal II: DFS is cool...BFS using one queue 

Binary Tree Maximum Path Sum: hard

Binary Tree Postorder Traversal: medium pop condition

Binary Tree Zigzag Level Order Traversal: medium

Candy ※: medium. Greedy algorithm. Similar to Dijsktra

Climbing Stairs: DP with O(1) space

Clone Graph: BFS + hash

Combination Sum: recursion

Combination Sum II: recursion

Combinations: both iterative and recursion

Construct Binary Tree from Inorder and Postorder Traversal: easy

Construct Binary Tree from Preorder and Inorder Traversal: easy

Container With Most Water: hard greedy tricky

Contains Duplicates: cannot sort an empty array; C++ set insert return value is pair

Convert Sorted Array to Binary Search Tree: easy

Convert Sorted List to Binary Search Tree: medium global pointer bottom-up recursion 

Copy List with Random Pointer: deep copy queue

Count and Say: easy

Decode Ways: DP medium

Delete Node in a Linked List: fill instead of "real" deletion

Distinct Subsequences: DP medium

Divide Two Integers: binary medium

Edit Distance: DP medium

Evaluate Reverse Polish Notation: easy

Excel Sheet Column Number: no brainer

Factor Trailing Zeroes: math mod. similiar to Add Digits. 

First Missing Positive: classic

Flatten Binary Tree to Linked List: easy

Gas Station: easy greedy algorithm. Similar to Longest Consecutive Seq

Generate Parentheses: recursion

Gray Code: classic trick generating subsets or binary numbers

Happy Number: all about hash

House Robber: DP two params in equation = two variables

Implement Stack Using Queues: brilliant idea to use only one queue...making push() an O(n) operation...

Implement strStr(): easy

Insert Interval: medium

Insertion Sort List: medium

Integer to Roman: medium 

Interleaving String: DP

Intersection of Two Linked Lists: count number & GOD algo: length(A+B) = length(B+A), you will encounter either the common node or null

Invert Binary Tree: recursive

Jump Game: Greedy O(n) BFS or DFS

Jump Game II ※: DP BFS hard

Largest Rectangle in Histogram: left right idx problem. Non-descending sequence using stack

Length of Last Word: easy

Letter Combinations of a Phone Number: easy

Longest Common Prefix: easy

Longest Consecutive Sequence ※: hash

Longest Palindromic Substring: DP 

Longest Substring Without Repeating Characters: O(n) using hash 

Longest Valid Parentheses ※: stack + DP + max O(n) time complexity

Lowest Common Ancestor of a Binary Search Tree: easy

Lowest Common Ancestor of a Binary Tree: recursion does everything 

Majority Element: median or Moore voting algorithm

Maximal Rectangle ※: use union-find set to construct the monotone queue instead of the stack. Stack will exceed time limit for large judge. 

Maximum Depth of Binary Tree: easy

Maximum Product Subarray: medium DP

Maximum Subarray: easy

Median of Two Sorted Arrays: binary search hard 

Merge Intervals: easy

Merge k Sorted Lists: priority queue of size k

Merge Sorted Array: easy extremely short code

Merge Two Sorted List: easy

Minimum Depth of Binary Tree: make sure to understand the definition of minDepth which is to count the distance between root and the "leaf" node; when there is only one child...

Minimum Path Sum: DP

Minimum Window Substring ※: ascii hash 

Move Zeros: think through different cases before coding

Multiply Strings: medium large number or string

N-Queens: easy

N-Queens II: easy

Next Permutation: classic 

Nim Game: math 

Number of 1 Bits: n & (n - 1) trick for sparse ones

Palindrome Number: reverse half and compare 

Palindrome Partitioning: recursion

Palindrome Partitioning II: DP on sol and palindrome

Partition List: easy but kindof tricky..

Pascal's Triangle: one row DP 

Pascal's Triangle II: one row DP direction reversed

Path Sum: when tree is null, no leaf so no sum, not even 0 

Path Sum II: easy 

Permutation Sequence: easy 

Permutations: no duplicate recursion medium

Permutations II: next permutation problem

Plus One: know where to stop 

Populating Next Right Pointers in Each Node: easy

Populating Next Right Pointers in Each Node II: easy from right to left 

Pow(x, n): tricky Integer boundary

Power Of Three: zero handling and math

Recover Binary Search Tree: both recursively and iteratively medium

Regular Expression Matching: medium recursion

Remove Duplicates from Sorted Array: cnt method... 

Remove Duplicates from Sorted Array II: easy

Remove Duplicates from Sorted List: slim code!

Remove Duplicates from Sorted List II: easy

Remove Element: fixing one side && cnt method
Remove Nth Node From End of List: classic

Reorder List: easy detail..

Restore IP Addresses: recursion easy corner cases..

Reverse Integer: easy overflow

Reverse Linked List: pointer initialization...*p = NULL

Reverse Linked List II: classic 

Reverse Nodes in k-Group: easy

Reverse Words in a String: easy & tricky

Roman to Integer: math trick: sum += cur - 2 * (sum % cur)

Rotate Image: classic details

Rotate List: medium

Same Tree: easy

Scramble String: medium recursion & pruning

Search a 2D Matrix: binary search

Search for a Range: recursion or twice binary search

Search in Rotated Sorted Array: classic 

Search in Rotated Sorted Array II: medium

Search Insert Position: easy

Set Matrix Zeroes: details...

Simplify Path: easy details...

Single Number: easy classic xor

Single Number II ※: bits arithmetics, classic

Sort Colors: Dutch National Flag Problem loop invariant

Spiral Matrix: classic

Spiral Matrix II: easy

Sqrt(x): Newton and binary search 

String to Integer (atoi): boundary

Subsets: easy

Subsets II: both iterative and recursion. Recursion is the same with Combination Sum. Subsets could also use this recursion solution.  

Substring with Concatenation of All Words: hash hash

Sudoku Solver: medium boolean recursion & bit masking & 2-d array to 1-d array

Sum Root to Leaf Numbers: easy top-down

Surrounded Regions: medium queue

Swap Nodes in Pairs: easy fake head

Symmetric Tree: recursion - input; iteration by using one queue 

Text Justification: medium

Trapping Rain Water: double-way DP O(n)

Triangle: DP O(n^2)

Two Sum: hash / quicksort + binary 

Ugly Number: corner case ZERO!

Unique Binary Search Trees: DP

Unique Binary Search Trees II: recursion

Unique Paths: DP 1d

Unique Paths II: DP 1d

Valid Anagram: vector initialization

Valid Palindrome: easy

Valid Parentheses: easy

Valid Sudoku: easy

Validate Binary Search Tree : similar to Balanced Tree

Wildcard Matching: hard

Word Break: DP

Word Break II ※: DP + parent + recursion. Note time efficiency

Word Ladder: BFS using queue and HashMap 

Word Ladder II: medium 

Word Pattern: medium

Word Search: recursion easy 

ZigZag Conversion: medium 
